package files

import (
	"bytes"
	"sync"
	"unicode/utf8"
)

var russianUnicodeDecode = map[[3]byte][]byte{
	{78, 8, 24}: {208, 144}, {78, 8, 56}: {208, 176}, {78, 8, 25}: {208, 145}, {78, 8, 57}: {208, 177}, {78, 8, 26}: {208, 146},
	{78, 8, 58}: {208, 178}, {78, 8, 27}: {208, 147}, {78, 8, 59}: {208, 179}, {78, 24, 24}: {208, 148}, {78, 24, 56}: {208, 180},
	{78, 24, 25}: {208, 149}, {78, 24, 57}: {208, 181}, {78, 8, 9}: {208, 129}, {78, 8, 89}: {209, 145}, {78, 24, 26}: {208, 150},
	{78, 24, 58}: {208, 182}, {78, 24, 27}: {208, 151}, {78, 24, 59}: {208, 183}, {78, 40, 24}: {208, 152}, {78, 40, 56}: {208, 184},
	{78, 40, 25}: {208, 153}, {78, 40, 57}: {208, 185}, {78, 40, 26}: {208, 154}, {78, 40, 58}: {208, 186}, {78, 40, 27}: {208, 155},
	{78, 40, 59}: {208, 187}, {78, 56, 24}: {208, 156}, {78, 56, 56}: {208, 188}, {78, 56, 25}: {208, 157}, {78, 56, 57}: {208, 189},
	{78, 56, 26}: {208, 158}, {78, 56, 58}: {208, 190}, {78, 56, 27}: {208, 159}, {78, 56, 59}: {208, 191}, {78, 8, 40}: {208, 160},
	{78, 8, 72}: {209, 128}, {78, 8, 41}: {208, 161}, {78, 8, 73}: {209, 129}, {78, 8, 42}: {208, 162}, {78, 8, 74}: {209, 130},
	{78, 8, 43}: {208, 163}, {78, 8, 75}: {209, 131}, {78, 24, 40}: {208, 164}, {78, 24, 72}: {209, 132}, {78, 24, 41}: {208, 165},
	{78, 24, 73}: {209, 133}, {78, 24, 42}: {208, 166}, {78, 24, 74}: {209, 134}, {78, 24, 43}: {208, 167}, {78, 24, 75}: {209, 135},
	{78, 40, 40}: {208, 168}, {78, 40, 72}: {209, 136}, {78, 40, 41}: {208, 169}, {78, 40, 73}: {209, 137}, {78, 40, 42}: {208, 170},
	{78, 40, 74}: {209, 138}, {78, 40, 43}: {208, 171}, {78, 40, 75}: {209, 139}, {78, 56, 40}: {208, 172}, {78, 56, 72}: {209, 140},
	{78, 56, 41}: {208, 173}, {78, 56, 73}: {209, 141}, {78, 56, 42}: {208, 174}, {78, 56, 74}: {209, 142}, {78, 56, 43}: {208, 175},
	{78, 56, 75}: {209, 143},
}

var russianUnicodeEncode = map[[2]byte][]byte{
	{208, 144}: {228, 128, 129}, {208, 160}: {228, 128, 130}, {208, 176}: {228, 128, 131}, {209, 128}: {228, 128, 132},
	{208, 129}: {228, 128, 144}, {208, 145}: {228, 128, 145}, {208, 161}: {228, 128, 146}, {208, 177}: {228, 128, 147},
	{209, 129}: {228, 128, 148}, {209, 145}: {228, 128, 149}, {208, 146}: {228, 128, 161}, {208, 162}: {228, 128, 162},
	{208, 178}: {228, 128, 163}, {209, 130}: {228, 128, 164}, {208, 147}: {228, 128, 177}, {208, 163}: {228, 128, 178},
	{208, 179}: {228, 128, 179}, {209, 131}: {228, 128, 180}, {208, 148}: {228, 129, 129}, {208, 164}: {228, 129, 130},
	{208, 180}: {228, 129, 131}, {209, 132}: {228, 129, 132}, {208, 149}: {228, 129, 145}, {208, 165}: {228, 129, 146},
	{208, 181}: {228, 129, 147}, {209, 133}: {228, 129, 148}, {208, 150}: {228, 129, 161}, {208, 166}: {228, 129, 162},
	{208, 182}: {228, 129, 163}, {209, 134}: {228, 129, 164}, {208, 151}: {228, 129, 177}, {208, 167}: {228, 129, 178},
	{208, 183}: {228, 129, 179}, {209, 135}: {228, 129, 180}, {208, 152}: {228, 130, 129}, {208, 168}: {228, 130, 130},
	{208, 184}: {228, 130, 131}, {209, 136}: {228, 130, 132}, {208, 153}: {228, 130, 145}, {208, 169}: {228, 130, 146},
	{208, 185}: {228, 130, 147}, {209, 137}: {228, 130, 148}, {208, 154}: {228, 130, 161}, {208, 170}: {228, 130, 162},
	{208, 186}: {228, 130, 163}, {209, 138}: {228, 130, 164}, {208, 155}: {228, 130, 177}, {208, 171}: {228, 130, 178},
	{208, 187}: {228, 130, 179}, {209, 139}: {228, 130, 180}, {208, 156}: {228, 131, 129}, {208, 172}: {228, 131, 130},
	{208, 188}: {228, 131, 131}, {209, 140}: {228, 131, 132}, {208, 157}: {228, 131, 145}, {208, 173}: {228, 131, 146},
	{208, 189}: {228, 131, 147}, {209, 141}: {228, 131, 148}, {208, 158}: {228, 131, 161}, {208, 174}: {228, 131, 162},
	{208, 190}: {228, 131, 163}, {209, 142}: {228, 131, 164}, {208, 159}: {228, 131, 177}, {208, 175}: {228, 131, 178},
	{208, 191}: {228, 131, 179}, {209, 143}: {228, 131, 180},
}

func encode(data []byte) []byte {
	var (
		result = make([][]byte, len(data))
		wg     sync.WaitGroup
	)

	for i := 0; i < len(data); i++ {
		b := data[i]
		switch b {
		case 34, 51, 68, 85, 102, 119:
			result[i] = []byte{b}
			continue
		case 194, 195:
			if i+1 < len(data) {
				r, _ := utf8.DecodeRune([]byte{b, data[i+1]})
				b = nibbleSwap(byte(r))
				result[i] = []byte(string(b))
				i++
				continue
			}
		case 208, 209:
			if i+1 < len(data) {
				key := [2]byte{b, data[i+1]}
				if v, ok := russianUnicodeEncode[key]; ok {
					result[i] = v
					i++
					continue
				}
			}
		}

		wg.Add(1)
		go func(i int, b byte) {
			defer wg.Done()
			b = nibbleSwap(b)
			result[i] = []byte(string(b))
		}(i, b)
	}

	wg.Wait()

	return bytes.Join(result, []byte{})
}

func decode(data []byte) []byte {
	var (
		result = make([]byte, len(data))
		wg     sync.WaitGroup
		shift  bool
		skip   int
	)

	for i, b := range data {
		switch b {
		case 34, 51, 68, 85, 102, 119:
			result[i-skip] = b
			continue
		case 194, 195:
			shift = b == 195
			skip++
			continue
		}

		wg.Add(1)
		go func(i int, b byte, shift bool) {
			defer wg.Done()
			b = nibbleSwap(b)
			if shift {
				b += 4
			}
			result[i] = b
		}(i-skip, b, shift)

		shift = false
	}

	wg.Wait()

	result = result[:len(result)-skip]
	extended := make([]byte, 0, len(result))
	for i := 0; i < len(result); i++ {
		b := result[i]
		if b == 78 && i+2 < len(result) {
			key := [3]byte{b, result[i+1], result[i+2]}
			if v, ok := russianUnicodeDecode[key]; ok {
				extended = append(extended, v...)
				i += 2
				continue
			}
		}
		bb := []byte(string(b))
		extended = append(extended, bb...)
	}

	return extended
}

func nibbleSwap(b byte) byte {
	return (b << 4 & 0xF0) | (b >> 4 & 0x0F)
}
